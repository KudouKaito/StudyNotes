# Tue Feb 28 10:27:07 AM CST 2023
&emsp;&emsp;之前在知网上找智能无人叉车论文没找到别人的具体方案，找到的大部分都是视觉算法，这两天直接在必应上搜索相关方案了。
&emsp;&emsp;智能无人驾驶叉车，也叫AGV叉车。AGV叉车有两类方案，一类是自由路径方式，另一类是固定路径方式。[1](https://zhuanlan.zhihu.com/p/158551032)
&emsp;&emsp;在识别方面，识别可以用视觉轮廓识别，导航可以使用视觉SLAM导航。目前还没定好要用但目摄像头还是双目摄像头。  
![视觉SLAM简单介绍]( https://cloud.tencent.com/developer/news/609998)
![视觉SLAM详细介绍](https://zhuanlan.zhihu.com/p/140890576)  
![视觉轮廓识别，边缘检测与定位中心点识别](http://hfyh-ai.com/jjfa/show-194.html)  



# Thu Mar  2 10:51:48 AM CST 2023
&emsp;&emsp;这两天在配置vnc，但是TX2不像树莓派那样可以不插显示器就能强制输出HDMI信号，TX2不插显示器就不会有:0桌面，所以TX2不插显示器无法使用x0vncserver和vino，除非用xorg什么玩意dummy创建一个虚拟显示器，但是创建了这个虚拟显示器之后，物理显示器就没办法显示了，为了不让后人使用这个TX2的时候误认为这个TX2坏掉了，我没有采用这个方案。
&emsp;&emsp;于是我采用vnc4server或者tigervnc创建虚拟桌面:1 :2的方式进行连接，每次都手动连接ssh启动vnc或者将vncserver的启动加入到启动文件里面去。  
&emsp;&emsp;但是我发现xstartup里面的图形程序一个都没有启动成功。我设置export DISPLAY=:1，然后手动启动报错  
```
# Error constructing proxy for org.gnome.Terminal:/org/gnome/Terminal/Factory0: Error calling StartServiceByName for org.gnome.Terminal: Timeout was reached
```  
&emsp;&emsp;问了一下new bing，它告诉我使用dbus-launch gnome-terminal 来启动，这次是启动成功了，但是返回一个信息
```
Unable to create /home/nvidia/.dbus/session-bus
```
&emsp;&emsp;查了一下发现home目录下.dbus的所有者是root，按理来说这个目录的权限应该是本用户才对，改了之后就可以使用了。  

&emsp;&emsp;搞了很久，gnome-session还是没办法启动，最后还是换了xfce4  
```bash
#!/bin/sh

# Uncomment the following two lines for normal desktop:
# unset SESSION_MANAGER
# exec /etc/X11/xinit/xinitrc

[ -x /etc/vnc/xstartup ] && exec /etc/vnc/xstartup
[ -r $HOME/.Xresources ] && xrdb $HOME/.Xresources
xsetroot -solid grey
vncconfig -iconic &
x-terminal-emulator -geometry 80x24+10+10 -ls -title "$VNCDESKTOP Desktop" &
# 下面这一行去掉，不然窗口管理器会和xfce4的xfwm4冲突, 导致xfce4的窗口管理器启动不起来  
#x-window-manager &
startxfce4 &
```
&emsp;&emsp;前面两行不要解除注释，解除注释之后就没办法启动了，我也不知道是为什么，应该是用xinitrc来启动桌面的时候才会用到前面两行  

&emsp;&emsp;vnc通过ssh连接之后手动输入vncserver 来启动，启动的第一个服务端口是5901   

安装fish shell 把默认shell  
![fish官网](./image/ubuntu_fish_shell.png)
```
sudo apt-add-repository ppa:fish-shell/release-3
sudo apt update
sudo apt install fish
```
[设置默认shell-通过 .bashrc 启动 fish](https://wiki.archlinuxcn.org/wiki/Fish?rdfrom=https%3A%2F%2Fwiki.archlinux.org%2Findex.php%3Ftitle%3DFish_%28%25E7%25AE%2580%25E4%25BD%2593%25E4%25B8%25AD%25E6%2596%2587%29%26redirect%3Dno#%E5%B0%86_fish_%E8%AE%BE%E4%B8%BA%E9%BB%98%E8%AE%A4_shell)
将`fish`加入到~./bashrc的最后一行  



在linux上安装conda，因为tx2是aarch64架构的，所以装archiconda更适合一些  
https://github.com/Archiconda/build-tools 下载release然后运行shell文件即可安装，或者用wget是下载  
```
wget https://github.com/Archiconda/build-tools/releases/download/0.2.3/Archiconda3-0.2.3-Linux-aarch64.sh
sudo sh Archiconda3-0.2.3-Linux-aarch64.sh
```
我用的是fish，安装程序询问是否将conda加入到.bashrc中，选择不加。安装完之后手动把`source ~/archiconda3/etc/fish/conf.d/conda.fish`加到~/.config/fish/config.fish中去



# Tue Mar  7 04:19:00 PM CST 2023

&emsp;&emsp;摄像头的读取  
```python
import cv2

cap = cv2.VideoCapture(1)
while(True):
    ret, frame = cap.read()
    cv2.imshow("video", frame)
    c = cv2.waitKey(50)
    if c == 27:
        break
```



# Thu Mar  9 05:27:10 PM CST 2023

```
conda create -n SOLOv2 python=3.9
conda activate SOLOv2
```

< 下面是官网的安装渠道，但是官网根本没有提供aarch64架构的whl，所以行不通
[pytorch](https://pytorch.org/get-started/locally/)
[找到对应CUDA版本](https://pytorch.org/get-started/previous-versions/)
```
pip3 install torch torchvision torchaudio --extra-index-url https://download.pytorch.org/whl/cu116
```
这时候就发现没有对应版本了  

< 下面换英伟达官网，我开了个梯子  
[PyTorch For Jetson](https://forums.developer.nvidia.com/t/pytorch-for-jetson/72048)

我的jetson tx2的jetson版本是4.6的，这样的话最高就只能选择 PyTorch v1.10.0 了，而且python版本必定需使用3.6的  

构建detectron2
https://detectron2.readthedocs.io/en/latest/tutorials/install.html

detectron2 最低python版本要求python3.7但是tx2最高pytorch只支持3.6  
方案1 把jetpack版本升上去安装更高版本的pytorch
> 方案1失败，因为TX2最高jetpack版本支持就4.6了，不能再高了

方案2 jetpack版本不变，手动编译pytorch  
我仍然选择pytorch1.8.0, 选择python3.8编译  
刚开始跟着csdn和官方的readme去编译了，但是好多包都不存在，后来才发现官方readme有一句
If you are building for NVIDIA's Jetson platforms (Jetson Nano, TX1, TX2, AGX Xavier), Instructions to install PyTorch for Jetson Nano are [available here](https://devtalk.nvidia.com/default/topic/1049071/jetson-nano/pytorch-for-jetson-nano/)  
才发现英伟达那个帖子不止提供whl包，还提供构建教程，只不过在下面没有展开。  

要注意的点  
1. 分配虚拟内存，在帖子最前面有说，要不然会发生段错误，听说峰值内存能到24G(我可分配不了这么大，目前分配的是5G虚拟内存+8G TX2的物理内存一共13G内存)  
2. 保证拥有足够的储存空间，TX2 32G储存空间还是太少了，我选择了插一个EXT4的U盘进去编译  

如果编译一直出现segment fault， 可以改一下代码，[这个帖子](https://blog.csdn.net/qq_38026359/article/details/122081604)  
编译了几次编译成功  


> 这个方案的问题：  
> 1. tx2 aarch64 框架很多包都没有二进制的，就算有也不符合算法要求，得自己编译 
> 2. 实例分割算法性能要求应该还是比较高的，TX2不知道能不能顶得住  
> 3. 数据集，如果要用机器视觉的话，数据集需要自己标，工作量还是比较大的   
> 另外，这个TX2是32G的，空间是真的小，系统加CUDA、CUDNN都快二十多G了，不够的话只能插卡把代码什么的放进去了    
> 现在开了个会之后，觉得改个方案，不用机器视觉实例分割了，直接使用传统视觉，比如颜色识别边缘检测之类的，还有通过二维码的辅助来进行识别，谢耀庆来给我看了一下ROS，ROS有很多相关的功能，所以打算从ROS入手  
ros的学习看的是古月居的课  
# ros的安装  
https://wiki.ros.org/melodic/Installation/Ubuntu  
确保"restricted," "universe," and "multiverse." 源是开启的  
添加ros源
```
sudo sh -c '. /etc/lsb-release && echo "deb http://mirrors.ustc.edu.cn/ros/ubuntu/ `lsb_release -cs` main" > /etc/apt/sources.list.d/ros-latest.list'
```
设置apt-key，这一步我用了代理，应该也可以选择fastgit.org的镜像  
```
curl -s https://raw.githubusercontent.com/ros/rosdistro/master/ros.asc | sudo apt-key add -
```
```
sudo apt update
sudo apt install ros-melodic-desktop-full
```
在~/.bashrc里面添加环境变量，在fish之前加一行`source /opt/ros/melodic/setup.bash`  

安装构建工具  
```
sudo apt install python-rosdep python-rosinstall python-rosinstall-generator python-wstool build-essential
```
初始化rosdep，得访问外网  
```
sudo rosdep init
rosdep update
```

# 运行roscore启动rosmaster  
直接在命令行输入roscore，回车  
可能会出现的问题：  
```
nvidia@nvidia-desktop /o/r/m/include> roscore
Traceback (most recent call last):
  File "/opt/ros/melodic/bin/roscore", line 36, in <module>
    from rosmaster.master_api import NUM_WORKERS
  File "/opt/ros/melodic/lib/python2.7/dist-packages/rosmaster/__init__.py", line 35, in <module>
    from .main import rosmaster_main
  File "/opt/ros/melodic/lib/python2.7/dist-packages/rosmaster/main.py", line 43, in <module>
    import rosmaster.master
  File "/opt/ros/melodic/lib/python2.7/dist-packages/rosmaster/master.py", line 47, in <module>
    import rosmaster.master_api
  File "/opt/ros/melodic/lib/python2.7/dist-packages/rosmaster/master_api.py", line 72, in <module>
    from rosmaster.util import xmlrpcapi
  File "/opt/ros/melodic/lib/python2.7/dist-packages/rosmaster/util.py", line 48, in <module>
    from defusedxml.xmlrpc import monkey_patch
ModuleNotFoundError: No module named 'defusedxml'
```
这是因为ros依赖的Python版本是2.7版本（这也太老了），而系统的/usr/bin/python则是链接到python3的，可以手动更改一下软链接，ubuntu dpkg提供有一个alternatives工具用来切换软件版本的
```
# 查看命令版本列表
update-alternatives --list python
# 配置命令版本  
update-alternatives --config python
```
将python版本选择为2.7就可以正常运行了，我的输出结果是这样的  
```
nvidia@nvidia-desktop /o/r/m/include> roscore
... logging to /home/nvidia/.ros/log/b93a83da-c2e2-11ed-bcd3-00044b8d6ecc/roslaunch-nvidia-desktop-337.log
Checking log directory for disk usage. This may take a while.
Press Ctrl-C to interrupt
Done checking log file disk usage. Usage is <1GB.

started roslaunch server http://nvidia-desktop:46343/
ros_comm version 1.14.13


SUMMARY
========

PARAMETERS
 * /rosdistro: melodic
 * /rosversion: 1.14.13

NODES

auto-starting new master
process[master]: started with pid [350]
ROS_MASTER_URI=http://nvidia-desktop:11311/

setting /run_id to b93a83da-c2e2-11ed-bcd3-00044b8d6ecc
process[rosout-1]: started with pid [366]
started core service [/rosout]
```

# ros的学习使用  
我把代码空间放在sd卡里面去，cd到sd卡中，并创建文件夹  
```
nvidia@nvidia-desktop /m/n/2a938e3f-9826-40e2-8907-7b6e5fb8ae8f> mkdir -p catkin_ws/src
```
> 如果这里有权限问题，可以用chown改一下sd卡的所有者（默认是root）`sudo chown -R nvidia:nvidia ./`  
初始化源码空间  
```
nvidia@nvidia-desktop /m/n/2/catkin_ws> cd src/
nvidia@nvidia-desktop /m/n/2/c/src> catkin_init_workspace
Creating symlink "/media/nvidia/2a938e3f-9826-40e2-8907-7b6e5fb8ae8f/catkin_ws/src/CMakeLists.txt" pointing to "/opt/ros/melodic/share/catkin/cmake/toplevel.cmake"
```
这时候就会生成一个CMakeLists.txt的软链接  
编译项目  
```
# 回到工作空间根目录  
nvidia@nvidia-desktop /m/n/2/c/src> cd ..
# 编译
nvidia@nvidia-desktop /m/n/2/catkin_ws> catkin_make
Base path: /media/nvidia/2a938e3f-9826-40e2-8907-7b6e5fb8ae8f/catkin_ws
Source space: /media/nvidia/2a938e3f-9826-40e2-8907-7b6e5fb8ae8f/catkin_ws/src
Build space: /media/nvidia/2a938e3f-9826-40e2-8907-7b6e5fb8ae8f/catkin_ws/build
Devel space: /media/nvidia/2a938e3f-9826-40e2-8907-7b6e5fb8ae8f/catkin_ws/devel
Install space: /media/nvidia/2a938e3f-9826-40e2-8907-7b6e5fb8ae8f/catkin_ws/install
####
#### Running command: "cmake /media/nvidia/2a938e3f-9826-40e2-8907-7b6e5fb8ae8f/catkin_ws/src -DCATKIN_DEVEL_PREFIX=/media/nvidia/2a938e3f-9826-40e2-8907-7b6e5fb8ae8f/catkin_ws/devel -DCMAKE_INSTALL_PREFIX=/media/nvidia/2a938e3f-9826-40e2-8907-7b6e5fb8ae8f/catkin_ws/install -G Unix Makefiles" in "/media/nvidia/2a938e3f-9826-40e2-8907-7b6e5fb8ae8f/catkin_ws/build"
####
-- The C compiler identification is GNU 7.5.0
-- The CXX compiler identification is GNU 7.5.0
-- Check for working C compiler: /usr/bin/cc
-- Check for working C compiler: /usr/bin/cc -- works
-- Detecting C compiler ABI info
-- Detecting C compiler ABI info - done
-- Detecting C compile features
-- Detecting C compile features - done
-- Check for working CXX compiler: /usr/bin/c++
-- Check for working CXX compiler: /usr/bin/c++ -- works
-- Detecting CXX compiler ABI info
-- Detecting CXX compiler ABI info - done
-- Detecting CXX compile features
-- Detecting CXX compile features - done
-- Using CATKIN_DEVEL_PREFIX: /media/nvidia/2a938e3f-9826-40e2-8907-7b6e5fb8ae8f/catkin_ws/devel
-- Using CMAKE_PREFIX_PATH: /opt/ros/melodic
-- This workspace overlays: /opt/ros/melodic
-- Found PythonInterp: /usr/bin/python2 (found suitable version "2.7.17", minimum required is "2")
-- Using PYTHON_EXECUTABLE: /usr/bin/python2
-- Using Debian Python package layout
-- Using empy: /usr/bin/empy
-- Using CATKIN_ENABLE_TESTING: ON
-- Call enable_testing()
-- Using CATKIN_TEST_RESULTS_DIR: /media/nvidia/2a938e3f-9826-40e2-8907-7b6e5fb8ae8f/catkin_ws/build/test_results
-- Found gtest sources under '/usr/src/googletest': gtests will be built
-- Found gmock sources under '/usr/src/googletest': gmock will be built
-- Found PythonInterp: /usr/bin/python2 (found version "2.7.17")
-- Looking for pthread.h
-- Looking for pthread.h - found
-- Looking for pthread_create
-- Looking for pthread_create - not found
-- Looking for pthread_create in pthreads
-- Looking for pthread_create in pthreads - not found
-- Looking for pthread_create in pthread
-- Looking for pthread_create in pthread - found
-- Found Threads: TRUE
-- Using Python nosetests: /usr/bin/nosetests-2.7
-- catkin 0.7.29
-- BUILD_SHARED_LIBS is on
-- BUILD_SHARED_LIBS is on
-- Configuring done
-- Generating done
-- Build files have been written to: /media/nvidia/2a938e3f-9826-40e2-8907-7b6e5fb8ae8f/catkin_ws/build
####
#### Running command: "make -j6 -l6" in "/media/nvidia/2a938e3f-9826-40e2-8907-7b6e5fb8ae8f/catkin_ws/build"
####
nvidia@nvidia-desktop /m/n/2/catkin_ws>
```

我用的是fish，官方没有提供fish的脚本，但是官方提供了一个fish对应的使用方法  
http://wiki.ros.org/rosbash  
通过bass来运行bash脚本  
我选择通过fisher来安装bass，fisher似乎是一个更为轻量化的fish插件管理器，而且还兼容oh-my-fish的插件  
```
curl -sL https://raw.githubusercontent.com/jorgebucaran/fisher/main/functions/fisher.fish | source && fisher install jorgebucaran/fisher
fisher install edc/bass
```
我把自动切换工作目录的脚本添加到了fish中  
`vim ~/.config/fish/conf.d/catkin.autosource.fish`向fish添加函数输入一下内容`:wq`保存   
```
function catkinSource --on-variable PWD
    status --is-command-substitution; and return
    if test -e ".catkin_workspace"; or test -e ".catkin_tools"
        bass source devel/setup.bash
        echo "Configured the folder as a workspace"
    end
end
```
将rosfish添加到fish的配置中，不然补全不好用  
```
echo "source /opt/ros/melodic/share/rosbash/rosfish" > ~/.config/fish/conf.d/rosfish.fish
```

# 创建功能包  
创建功能包，这个功能包就是我们要写的代码，而不是现成的库。代码写在catkin_ws/src/learning_communication/src 里面    
```bash
cd catkin_ws/src
catkin_create_pkg learning_communication
```
回到catkin_ws工作空间根目录，编译功能包  
```bash 
catkin_make
# 因为我已经配置了自动bass source， 所以不用再手动source了
# source devel/setup.bash
```
写代码
```c
/*
 /media/nvidia/2a938e3f-9826-40e2-8907-7b6e5fb8ae8f/catkin_ws/src/learning_communication/src/talker.cpp
*/


#include <sstream>
#include "ros/ros.h"
#include "std_msgs/String.h"

int main (int argc, char **argv)
{
    ros::init(argc, argv, "talker");
    ros::NodeHandle n;
    // n.advertise是一个泛型函数
    ros::Publisher chatter_pub = n.advertise<std_msgs::String>("chatter", 1000);
    ros::Rate loop_rate(10);
    int count = 0;
    while (ros::ok())
    {
        std_msgs::String msg;
        std::stringstream ss;
        ss << "hello world " << count;
        msg.data = ss.str();

        ROS_INFO("%s", msg.data.c_str());
        chatter_pub.publish(msg);

        ros::spinOnce();

        loop_rate.sleep();
        ++count;
    }
    return 0;

}
```

```C
/*
 /media/nvidia/2a938e3f-9826-40e2-8907-7b6e5fb8ae8f/catkin_ws/src/learning_communication/src/listener.cpp
*/

#include "ros/ros.h"
#include "std_msgs/String.h"

void chatterCallback(const std_msgs::String::ConstPtr& msg)
{
    ROS_INFO("I heard: [%s]", msg->data.c_str());
}

int main(int argc, char **argv)
{
    ros::init(argc, argv, "listener");
    ros::NodeHandle n;
    ros::Subscriber sub = n.subscribe("chatter", 1000, chatterCallback);
    ros::spin();
    return 0;
}
```

修改CMakeLists.txt，修改的是catkin_ws/src/learning_communication 里面的CMakeLists.txt  

在文件里面找到`add_executable`  

```sh
# add_executable(可执行文件名字 源码路径) 

add_executable(talker src/talker.cpp)
target_link_libraries(talker ${catkin_LIBRARIES})
# add_dependencies(talker ${PPRJECT_NAME}_gencpp)

add_executable(listener src/listener.cpp)
target_link_libraries(listener ${catkin_LIBRARIES})
# add_dependencies(listener ${PPRJECT_NAME}_gencpp})
 
```




# 定义话题消息  
在功能包的目录下面创建msg文件夹，存放msg文件  
(realpath可以输出文件绝对路径)
`/media/nvidia/2a938e3f-9826-40e2-8907-7b6e5fb8ae8f/catkin_ws/src/learning_communication/msg/Person.msg`
```
string name
uint8 sex
uint8 age

uint8 unkonwn = 0
uint8 male = 1
uint8 female = 2
```
在package.xml中添加功能包依赖（参照文件里面其他依赖包添加就可以了）
```
<build_depend>message_generation</build_depend>
<exec_depend>message_runtime</exec_depend>
```
在CMakeLists.txt添加编译选项  
分别找到find_package()、caktin_package()、add_message_file()、generate_messages()，添加成一下内容  
```
find_package(......message_generation)
catkin_package(CATKIN_DEPENDS geometry_msgs roscpp rospy std_msgs message_runtime)
add_message_files(FILES Person.msg)
generate_messages(DEPENDENCIES std_msgs)
```

添加service也是类似的，只不过msg文件变成了srv文件
```
# 注释不能写到文件中去
# ---上面的是请求数据
int64 a
int64 b
---
int64 sum
# --- 下面的是应答数据
```

```
在package..xml中添加功能包依赖
<build_depend>message_generation</build_depend>
<exec_depend>message_runtime</exec_depend>
在CMakeLists.txt添加编译选项
find_package(......message_generation)
catkin_package(CATKIN_DEPENDS geometry_msgs roscpp
rospy std_msgs message_runtime)
add_service_files(FILES AddTwolnts.srv)
```
> 要保证add_service_files里面的文件和创建的名字一样并且和代码里面include的一样，我就是有Two错打成了Tow，然后代码里面include的是Two结果报的错，还有还要在CMakeLists.txt里面取消注释或者写一句    
```bash
generate_messages(
  DEPENDENCIES
  std_msgs
)
```


# rviz 
因为在vnc中无法使用rviz, 于是我就在我本机上也装了一个ros用来启动rviz, 我的archlinux只有ros-noetic的版本，在arch4edu源里面。  
不同版本的ros好像是可以通信的。  

hosts一定要改，要不然程序使用的是计算机名识别，即使使用ip来指定，程序使用的还是计算机名，所以ros系统一定要在hosts中将计算机名和ip给绑定  


# 安装freenect
> 这玩意好像没有必要，后来才发现这个东西是微软的一个Kinect设备相关的东西    
```shell
sudo apt install ros-melotic-freenect-\*
# bash中不需要反斜杠
git clone https://github.com/avin2/SensorKinect.git
cd SensorKinect/Bin
tar xvf SensorKinect093-Bin-Linux-x86-v5.1.2.1.tar.bz2
cd Sensor-Bin-Linux-x86-v5.1.2.1
sudo ./install.sh
```


# URDF建模  

## 常量
和shell的常量差不多  
```xml
<xacro:property name="M_PI" value="3.14159"/>
<origin xyz="0 0 0" rpy="${M_PI/2} 0 0"/>
```
# xacro建模是URDF建模的延伸，是一种宏文件

# 摄像头的标定  
先安装标定功能包  
```
sudo apt-get install ros-melodic-camera-calibration
```
```
>启动摄像头
roslaunch robot_vision usb_cam.launch
>启动标定包
rosrun camera_calibration cameracalibrator.py --size 8x6 --square 0.024 image:=/usb_cam/image_raw camera:=/usb_cam
```



2.54 7PIN







